---
title: Polymorphism
tags:
  - react
  - hooks
  - javascript
date: 2019-12-15
excerpt: This is a blog relating to Polymorphism in Python.
external: false
url: ""
---

# Polymorphism and special methods

---

# Polymorphism

- Ability to define a generic type of behavior that will potentially behave differently when applied to different types.
- For instance when we iterate over a collection, the object just needs to support the iterable protocol, does not matter if itâ€™s a list, tuple, generator, etc.

## `__str__` and `__repr__`

- Both are used to give a representation of a class.
- `__str__` is used when a more user friendly output is required, `__repr__` is used in case of a more developer oriented output.
- `__repr__` is implemented by Python by default when we instantiate a class (even if itâ€™s empty). In case `__str__` is not present, upon printing or calling the object, `__repr__` is used as a fallback.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        print("repr has been called")
        return f"Person(name={self.name}, age={self.age})"

    def __str__(self):
        print("str has been called")
        return self.name

p1 = Person("pratik", 12)

print(p1)    # gives a more user friendly version
"""
str has been called
pratik
"""

str(p1)
"""
str has been called
'pratik'
"""

p1    # note that this works only in Jupyter kernel
"""
repr has been called
Person(name=pratik, age=12)
"""

repr(p1)
"""
repr has been called
Person(name=pratik, age=12)
"""
```

## Hashing and Equality

- Hashing and equality can be implemented using the `__hash__` and `__eq__` functions in a class. Each class is a subclass of _`Object`_ which provides default implementation of `__hash__` and `__eq__` .

<aside>
ðŸ’¡ If we implement the `__eq__` the default hash is overridden and `hash()` no longer works unless we implement it in the said class, we get a *unhashable type* exception.

</aside>

## Callables

- Any class can be made in a _callable_ by implementing the `__call__` method.

```python
class Person:
  def __call__(self, name):
    return f'Hello {name}'

p = Person()
p('there')    # Hello there

type(Person)    # type
```

- Functions are callable by default, we can make a class callable as well. Class would be of a type `type` and functions would be `function`.

<aside>
ðŸ’¡ To check if callable or not, use the `callable` function.

</aside>
