---
title: React Internals
tags:
  - react
  - internals
date: 2022-01-28
excerpt: How does React really work under the hood? Let's have a deep dive
external: false
url: ""
project: false
---

## Introduction

React is pretty fast and makes developing complex web applications simple. When I started learning it, React made writing complex logic in a few lines of code, which would take quite some time and effort to make in plain JavaScript.

It was almost magic!

Well, but it isn't. Under the hood, React just uses some clever engineering like virtual DOM, rendering, diffing algorithm and reconciliation which I hope to dive deep into.

## React components vs React elements vs Component instances

### React components

A React component is a reusable piece of code that defines a specific element or functionality in a React application. It is essentially a JavaScript function or class that returns a JSX element, which is then rendered to the browser as HTML.

React components are composed of two parts:

- **The state**: an object that contains data that can change and affect the component
- **The props**: an object that contains data passed from a parent component to a child component

A component can update its state, and in turn, update the rendered view. This allows for a dynamic and responsive user interface.

React also provides lifecycle methods, which are methods that get called at specific points in a component's lifecycle, such as when it first mounts, updates or unmounts, which allow developers to control how and when a component is updated.

In a nutshell, React components are the building blocks of a React application, allowing developers to create reusable and dynamic UI elements.

Below is an example of a class-based component,

```js
import React, { Component } from "react";

class Greeting extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

class App extends React.Component {
  render() {
    return (
      <div>
        <Greeting name="John" />
        <Greeting name="Jane" />
      </div>
    );
  }
}
```

The above code just outputs the following,

```
Hello, John!
Hello, Jane!
```

And here is the same component created using the functional approach,

```js
import React from "react";

const Greeting = (props) => {
  return <h1>Hello, {props.name}!</h1>;
};

function App() {
  return (
    <div>
      <Greeting name="John" />
      <Greeting name="Jane" />
    </div>
  );
}
```

If we were to log the actual component, it would give something like,

```js

Object {
  $$typeof: Symbol(react.element),
  type: "h1",
  key: null,
  ref: null,
  props: Object {
    children: "Hello, John!",
  },
  ...
}

```

which isn't really helpful for us mere mortals, but for React it is useful in understanding how to efficient update the view when the _props_ or _state_ change.

### So what really happens when we use a component?

The JSX gets converted to `React.createElement` function calls.Each function would return an object similar to the one above.

If we use class based components,

- React creates a new instance of the class and calls its `render()`
- The output is the output of the `render()`

If we use functional components,

- React calls the function with the props as the input
- The output is the output of the function, which is why we _need_ to have an output.

### React Element

A React element is a lightweight representation of a component or a DOM node. It's a plain JavaScript object that describes the component or DOM node and its properties. React elements are created when you write JSX and are used by React to efficiently update the view when the props or state change.

> `React.createElement(type, props, children)`

### Component instance

A component instance is a specific instance of a _component_ that is created with the component is rendered. Each time the component is rendered, it creates a new instance corresponding to that specific instance. Each instance has it's own state and props.

> In a nutshell, component is a blueprint that defines the reusable piece in the interface, component instance is a specific instance of a component that is created when the component is created and React element is a lightweight representation of a DOM node that is used to update the view efficiently.

- `$$typeof` is a property which is used by React to determine if the object is a React element, and is also used as a security measure. More about it on the following blog post,

<WebBookmark
  href="https://overreacted.io/why-do-react-elements-have-typeof-property/"
  title="Why do react elements have a typeof property"
/>

## Reconciliation

React initially creates a virtual DOM of elements. This is possible because elements are just plan JavaScript objects. Reconciliation is the process of determining how the virtual DOM shold change in response to the changes in props and state of that component.

When a component's props and states changes, React compares the virtual DOM with the new virtual DOM and calculates the minimal set of changes that need to be made to the original DOM.

This is done using an algorithm called _diffing_; The process of diffing is based on the concept of a tree structure, where the React component tree is compared to the new tree, and React can determine the difference between the two trees and only makes the necessary changes to the DOM.

Reconciliation is an important part of React's performance optimization, it allows React to minimize the number of changes that need to be made to the actual DOM, which in turn improves the performance of the application. This process is called "reconciliation" because it is the process of reconciling the virtual DOM with the actual DOM.

## How the `key` prop helps in the _diffing_ algorithm

React uses the `key` prop to keep track of individual elements in a list when it changes. It does this by comparing the old list to the new one and using the `key` prop to match elements that are the same. This way, React can reuse the same elements instead of having to recreate them, which helps improve performance.

When React compares two trees, it looks at elements at the same level. If it sees an element with a `key` prop in both trees, it checks the value of the `key` prop. If the value is the same, React knows the element is the same and doesn't update the DOM. If the value is different, React knows the element is different and updates the DOM.

It's important to remember that the `key` prop should be unique among siblings, should be a string or number, and should not change.

In short, React uses the `key` prop to keep track of elements in a list and improve performance by reusing elements instead of recreating them.

## So how **does** the _diffing_ algorithm really compare and make changes?

There are quite a few operations which are used to determine the most efficient ways to update the DOM. This allows React to make the least number of changes in the actual DOM which improves the performance.

Here are a few operations in the _diffing_ algorithm,

- **Mounting** - is used when a component is first added to the virtual DOM or tree.
- **Updating** - is used when a component's props or state are updated. Remember that a component has two parts, state and props.
- **Unmounting** - is used when the component is removed from the virtual DOM or tree.
- **Text updates** - are done when there are updates inside the _text_ of a component.
- **Reordering**- is used when the order of a list changes.
- **Keyed updates** - When we add an item to the start of the list (say), react compares the first element which does not match. Hence, instead of creating a new tree entirely from scratch, keys are used for creating just the items which are new in the children.

## Renderers

In React, _renderers_ are the components that are responsible for actually rendering elements on the screen. React provides different renderers for different platforms, such as React DOM for web browsers, React Native for mobile apps. Each renderer takes the virtual tree created by React and turns it into the actual elements that are displayed on the screen, such as HTML elements for web browsers and native elements for mobile apps.
