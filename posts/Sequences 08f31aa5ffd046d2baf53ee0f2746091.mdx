---
title: Sequences
tags:
  - react
  - hooks
  - javascript
date: 2019-12-15
excerpt: This is a blog relating to sequences in Python.
external: false
url: ""
---

## Basics

- Have a positional ordering
- Lists have a positional ordering, sets do not!

---

## Built in sequence types

- mutable
  - lists
  - bytearray
- immutable
  - strings
  - tuples
  - range
  - bytes

---

## Standard Sequence Methods

- x in s â†’ check if present
- x not in s â†’ check if not present
- s1 + s2 â†’ concatenation
- len(s)
- min(s) / max(s)
- s.index(x) â†’ index of first occurrence of x in s
- s.index(x, i) â†’ index of first occurrence of x in s at or after index i
- s.index(x, i, j) â†’ index of first occurrence of x in s at or after index i, before index j

---

## Methods used for mutable sequences types

- s.clear() â‡’ removes all the items from s
- s.insert(i, x) â‡’ inserts x at index i
- s.extend(iterable) â‡’ appends contents of an iterable
- s.remove(x) â‡’ remove an item 'x' from list
- s.reverse() â‡’ does an in-place reversal
- s.copy() â‡’ returns a _shallow_ copy

---

## Lists vs Tuples

- Firstly, lists are mutable while tuples are mutable.
- What that means is, basically tuples are treated as constants by Python. So when creating a new tuple, it would load in the values passed in the tuples as a constant and then build the tuple. In case of the list though, the values are _pushed_ and then the list is built.
- Look at the below code using the `dis`module to demonstrate this,

```python
from dis import dis

dis(compile('[1, 2, 3]', 'string', mode='exec'))
dis(compile('print("Hello")', 'string', mode='exec'))

"""
OUTPUT 1
0 LOAD_CONST               0 (1)
              2 LOAD_CONST               1 (2)
              4 LOAD_CONST               2 (3)
              6 BUILD_LIST               3
              8 POP_TOP
             10 LOAD_CONST               3 (None)
             12 RETURN_VALUE
"""

"""
OUTPUT 2
1           0 LOAD_NAME                0 (print)
              2 LOAD_CONST               0 ('Hello')
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
"""
```

- Also, when timed using `timeit`, the tuples are created faster than lists due to this.

<aside>
ðŸ’¡ Use tuples when dealing with data which might not change, lists otherwise.

</aside>

---

## Copying A Sequence

Different approaches to copying a sequence, like

```python
list_1 = [i for i in range(0, 10)]
```

1. Simple Loop

   ```python
   list_2 = []
   for i in list_1:
       list_2.append(i)
   ```

2. List Comprehensions

   ```python
   list_3 = [i for i in list_2]
   ```

3. Copy Method

   ```python
   list_4 = list_2.copy()
   ```

4. Slicing

```python
list_5 = list_1[0:len(list_1)]
# OR
list_5 = [:]
```

5. Creating a new list

```python
list_6 = list(list_1)
```

---

## Shallow Copy

When using the copy methods specified above, the all the object references are copied from one sequence to another. What that means is, all of the lists have a different id, but the **items in the list are having the same id**. This is the shallow copy.

The elements point to the same memory address as the original sequence elements.

<aside>
ðŸ’¡ Copies the container, not the sequence inside.

</aside>

If the values inside the container are mutable, then if the new lists are modified, the old one would be modified as well.

If the values inside the container are immutable, then the if the new lists are modified, the old one would not be modified.

---

## Deep Copy

So if the collections contain mutable elements, the shallow copies are not sufficient to ensure the copy can never be used to modify the original. Deep copy to the rescue!

Use the `copy` and `deepcopy` methods in the `copy` library. The former is a shallow copy and the latter is the deep copy.

---

## Slicing

- Slice definitions are actually objects in Python

  ```python
  s = slice(0, 3)
  type(s)    # slice

  my_list = [i for i in range(0, 10)]

  print(my_list[s])    #[0, 1, 2]

  print(s.start)
  print(s.stop)
  print(s.step)

  ```

### Ranges and Slices

- Ranges and slices are linked together
- The effective indices generated by the slice are actually dependent on the length of the sequence being sliced.
- **Transformations**
  Consider the list `['a', 'b', 'c', 'd', 'e', 'f']` **seq[ i : j ]** would be
  - if `i > len(seq)` â‡’ considers `len(seq)`
  - if `j > len(seq)` â‡’ considers `len(seq)`
  - if `i < 0` â‡’ considers `max(0, len(seq) + i)`
  - if `j < 0` â‡’ considers `max(0, len(seq) + j)`
  - if `i` is omitted or `None` â‡’ considers `0`
  - if `j` is omi`t`ted or `None` â‡’ considers `0`

---

## Finding why a slice is not working

Suppose there is a list,

```python
list_1 = [i for i in range(20)]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```

for which you need to find some range like,

```python
print(list_2[-10:10:-4])
```

Why? Why is this not printing anything?

Well, let's use the `indices()` to find this out!

```python
print(range(*slice(-10, 3, -4).indices(len(list_2))))
# range(10, 10, -4)
```

Here, the range is basically stating you want to go from 10, to 10, in steps of -4. Well, that is not going to happen.....

---

## In place Concatenation and Repetition

In case of any immutable types like tuples, strings when you use the `+=` operator, it's basically the same thing as just adding them. The ID of the LHS would be changed, a new one is created since you can't mutate them.

But, in case of immutable types, the Id remains the same as the LHS one. It's an in-place operation and changes the value!

---

## Custom Sequences - Mutable

```python
class MyClass:
    """
    m1 = MyClass('a')
    m2 = MyClass('b')
    """
    def __init__(self, name):
        """
        Constructor
        """
        self.name = name

    def __repr__(self):
        """
        Represents the object when printed
        """
        return "MyClass(name={})".format(self.name)

    def __add__(self, other):
        """
        ex - m1 + m2
        """
        return MyClass(self.name + other.name)

    def __iadd__(self, other):
        """
        ex - m3 += m1
        """
        if isinstance(other, MyClass):
            self.name += other.name
        else:
            self.name += other
        return self

    def __mul__(self, n):
        """
        ex - m1 * 2
        """
        return MyClass(self.name * n)

    def __rmul__(self, n):
        """
        ex - 3 * m1
        """
        return self.__mul__(n)

    def __imul__(self, n):
        """
        ex - m4 *= m1
        """
        self.name *= n
        return self

    def __contains__(self, value):
        """
        Check to see if value is present in the sequence
        ex - 'a' in m1
        """
        return value in self.name
```

---

## Sorting Sequences

- Sorting a sequence can be performed using the `sorted()` in Python. By default, it would be sorting in an ascending order but setting the _reverse=True_ would make it descending.

---

# Iterators and Iterables

## Why are sequences iterable? - The _iter_ Function

When the interpreter needs to iterate over an object x, _iter(x)_ would be automatically called, which

1. Checks whether the object implements the `__iter__` and calls that to obtain the iterator.
2. If `__iter__`is not implemented, but `__getitem__`is implemented, Python creates an iterator that attempts to fetch the items in order, starting from index 0
3. If that fails as well, Python raises `TypeError`

![https://learning.oreilly.com/library/view/fluent-python-2nd/9781492056348/assets/flup_1401.png](https://learning.oreilly.com/library/view/fluent-python-2nd/9781492056348/assets/flup_1401.png)

The standard interface for the **iterator** has 2 methods,

- `__next__` - which returns the next available item, raising a **`StopIteration`** when no more items are present
- `__iter__` - Returns `self`, which allows the iterators to be used where an iterable is expected, like in a `for` loop.

<aside>
ðŸ’¡ Iterable is the data collection or the data which is created only once
Iterator is the object which is used to iterate over the collection (iterable), **only once**

</aside>

## Iterable

Iterable is a Python object that implements the iterable protocol.

This protocol requires that the object implements a single method, `__iter__` which returns a new instance of the iterator object.

## Iterable vs Iterator

- An iterable is an object that implements

  - `__iter__` â‡’ returns an iterator

- An iterator is an object that implements
  - `__iter__` â‡’ returns itself (an interator) _not a new instance_
  - `__next__` â‡’ returns the next element

So, iterators are themselves iterables, but they become exhausted.

Iterables on the other hand never become exhausted since they return a new iterator which is used to iterate.

```python
from functools import lru_cache

@lru_cache(30)
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

class Fib:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return self.FibIterator(self, self.n)

    class FibIterator:
        def __init__(self, source, n):
            self.source = source
            self.n = n

        def __iter__(self):
            return self

        def __next__(self):
            while True:
                print("getting the {} fib number".format(self.n))
                result = fib(self.n)
                self.n += 1
                return result

f1 = Fib(0)
type(f1)
iter_f1 = iter(f1)

for _ in range(0, 10):
    time.sleep(0.5)
    print(next(iter_f1))
```

## Not making the iterable an iterator itself

- Iterables have an `__iter__` method that instantiates a new iterator every time.
- Iterators implement a `__next__` that returns the individual items and an `__iter__` that returns `self`.

<aside>
ðŸ’¡ Iterators are also iterable, but iterables are not iterators.

</aside>

[What exactly are iterator, iterable, and iteration?](https://stackoverflow.com/a/9884501)

---

## Cyclic Iterator

```python
class CyclicIterator:
    def __init__(self, lst):
        self._lst = lst
        self.i = 0

    def __iter__(self):
        return self

    def __next__(self):
        result = self._lst[self.i % len(self._lst)]
        self.i += 1
        return result
```

---

## Iterating a callable

Anything which can be _called_ in Python is a callable, function for instance is a callable.

It would be possible to have them iterated as in the below code,

```python
def random_number_generator(start=0, end=100):
    index = 0
    def inner():
        nonlocal index
        result = random.randint(start, end)
        index += 1
        print(result, index)
        return result
    return inner

generate = iter(random_number_generator(), 3)

for i in generate:
    i
```

Now if we were to directly use the function in the `iter` function, you'd get an error stating function cannot be iterated.

## The _iter_ function

- Returns an iterator for a given object.
- Syntax,
  ```python
  iter(object, sentinel)
  ```

where, object â†’ object whose iterator needs to be created

sentinel â†’ optional which represents the _end of sequence_

---

# Iteration Tools

## Aggregators

Functions that iterate through an _iterable_ and return a single value that takes into account every element of the iterable.

ex -

`min(iterable)` minimum value of the iterable

`max(iterable)` max value of the iterable

`sum(iterable)` sum of all the values in the iterable

<aside>
ðŸ’¡ Implementing the `__bool__` method overwrites the default behavior of truth values. If the class has no `__bool__` then Python checks for the `__len__`, if that's not present as well, it just returns a `True`.

</aside>

---

## Slicing Iterators using _islice_

Yes, it's possible to slice iterators as well... Pretty self explanotary so adding the code here just in case you have forgotten, which you most likely have.

```python
class RandomIterable:
    def __iter__(self):
        return self.RandomIterator()

    class RandomIterator:
        def __iter__(self):
            return self

        def __next__(self):
            return random.randint(0, 1000)
```

```python
from collections import abc

r1 = RandomIterable()
r1_iter = iter(r1)

print(isinstance(r1, abc.Iterator))
print(isinstance(r1, abc.Iterable))

print("\n")

print(isinstance(r1_iter, abc.Iterator))
print(isinstance(r1_iter, abc.Iterable))
```

```python
print(list(islice(r1_iter, 0, 45)))
```

---

## Infinite Iterators

### itertools._count(builtins.object)_

Returns a count object whose `next()` returns consecutive values.

For instance, `count(10, 2)` would return an iterator who would start at 10 and get incremented infinitely with step values of 2.

### _itertools.cycle(builtins.object)_

Returns an element from an iterator until it's exhausted and repeats that sequence indefinitely.

For instance, `count([1, 2, 3])` would return 1, 2, 3, 1, 2, 3..... indefinitely.

### _itertools.repeat(builtins.object)_

Creates an iterator which returns the **same** object for a specified number of times, if not specified endlessly.

<aside>
ðŸ’¡ This returns the *same object* at all times, does not create a new one. All point to the same memory location.

</aside>

### *itertools.chain(*args)\*

Chains the iterables and returns a new iterable.

Also done lazily.

If you need to chain an iterable inside another iterable, like

```python
l = [iter1, iter2, iter3]

chain(l) # would return only 'l'

# try this instead
chain(*l)

# but, since unpacking is eager, all the values would be unpacked eagerly

# alternative way is to use, chain.from_iterable which handles nested iterables
chain.from_iterable(l)
```

### _itertools.tee(iterable, n)_

Sometimes we need to iterate through the same iterable multiple times, even in parallel.

We could use the `tee` function in itertools modules like,

```python
teed = tee([1, 2, 3],10)

#which returns 10 instances of the list which could be iterated over
```

<aside>
ðŸ’¡ Returned elements are all independent instances of the same iterable, `id`s of each of the element are different

</aside>

```python
for i in teed:
    print(id(i))

"""
Returns
2469112765888
2469112744512
2469111288000
2469111290432
2469111291264
2469116369408
2469106854208
2469106852672
2469106853440
2469106854848"""
```

## Selecting and Filtering

### The filter function

- syntax â‡’ `filter(predicate, iterable)`
- returns all the elements of the iterable where predicate(element) is _True_
- Predicate can be `None`, in which case it's an identity function. Think, $f(x) = x$
- filter returns a _lazy iterator_
- We can also use them in generator functions, like
  - `(item for item in iterable if pred(item))` â‡’ predicate is not `None`
  - `(item for item in iterable if item)` â‡’ predicate is `None`

```python
from itertools import filterfalse

even = list(filterfalse(lambda x: x % 2 == 1, gen_cubes(20)))
print(even)
odd = list(filter(lambda x: x % 2 == 1, gen_cubes(20)))
print(odd)
```

### _itertools.compress(builtins.object)_

- Return the data elements corresponding to true selector elements.
- It's basically a way of filtering one iterable using the truthiness of another iterable.

```python
from itertools import compress
import random

data = [random.randint(0, 100) for _ in range(random.randint(0, 20))]
selectors = [random.randint(0, 1) for _ in range(random.randint(0, 20))]

print(data)    # [24, 97, 0, 98, 29, 47, 68, 41, 76, 55, 28, 81, 14, 20, 52, 57]
print(selectors)    # [0, 0, 0, 1, 1, 1]

for i in compress(data, selectors):
    print(i)

"""
Returns
98
29
47
"""
```

### _itertools.takewhile(builtin.object)_ and _itertools.dropwhile(builtin.object)_

- Takewhile
  - takewhile returns an iterator that will yield items while predicate is Truthy, after that all the items are exhausted and a `StopIteration` is raised.
  - Also returns a _lazy iterator_
- Dropwhile

  - dropwhile functions returns an iterator that will start iterating once predicate becomes Falsy.

  ```python
  from itertools import takewhile, dropwhile

  for i in takewhile(lambda x: x < 5, [1, 3, 5, 2, 1]):
      print(i)
  """
  Returns,
  1
  3
  """

  for i in dropwhile(lambda x: x < 5, [1, 3, 5, 2, 1, 10]):
      print(i)
  """
  Returns,
  5
  2
  1
  10
  """
  ```

## Group By

Yes, group by is present in Python as well...

- Group by in Python would be assuming that the elements present would be iterable as well.
- Group by in a nutshell would be returning the elements grouped along with another iterator having the elements to group them. Easier to demonstrate than tell....

```python
from itertools import groupby

l1 = list('AAAABBCCCCDEEEEFF')

for char, group in groupby(l1):
    print(char, '->', list(group))

"""
A -> ['A', 'A', 'A', 'A']
B -> ['B', 'B']
C -> ['C', 'C', 'C', 'C']
D -> ['D']
E -> ['E', 'E', 'E', 'E']
F -> ['F', 'F']
"""
```

<aside>
ðŸ’¡ The iterable that `groupby` returns is the same one for all, which means even if you don't use any one of them values, Python would automatically call `next()`and exhaust it before moving out to the next char.

</aside>

---

## Mapping and Accumulation

### Mapping

- Applying a callable to each element of an iterable
-

## Accumulation

- Reducing the iterable down to a single value
- examples
  - `sum(iterable)`
  - `min(iterable)`
  - `max(iterable)`
